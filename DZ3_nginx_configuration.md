1. Как найти публичный IP-адрес вашего сервера
Для того, чтобы найти публичный IP-адрес вашего сервера, найдите сетевые интерфейсы на вашей машине, набрав:

# ip addr

1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 52:54:00:71:40:6f brd ff:ff:ff:ff:ff:ff
    inet 89.108.65.9/24 brd 89.108.65.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 2a00:f940:2:4:2::902/64 scope global
       valid_lft forever preferred_lft forever
    inet6 fe80::5054:ff:fe71:406f/64 scope link
       valid_lft forever preferred_lft forever
3: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether 52:54:00:9b:50:b6 brd ff:ff:ff:ff:ff:ff


Если у вас есть имя интерфейса, вы можете запустить следующую команду, чтобы показать общественный IP-адрес вашего сервера. Подставьте имя интерфейса, найденное выше:

# ip addr show eth0 | grep inet | awk '{ print $2; }' | sed 's/\/.*$//'

    89.108.65.9
    2a00:f940:2:4:2::902
    fe80::5054:ff:fe71:406f


/.*//

<!-- Со всем, что выше написано - разобарться и записать -->





а вот вариант попроще
# curl ifconfig.me
89.108.65.9


утилиты curl и wget:

#curl ifconfig.me

или:

# curl smart-ip.net/myip

Эта команда выведет вам в консоль IP-адрес, с которого вы видны внешнему миру.

Аналогичной задаче может послужить и утилита wget:

# wget -O - -q icanhazip.com

или:

# wget -O - -q ifconfig.me/ip

Наиболее популярные:

# curl -s checkip.dyndns.org | sed -e 's/.*Current IP Address: //' -e 's/<.*$//'
# curl ipinfo.io/ip
# wget -qO- http://ipecho.net/plain
# curl ident.me
# curl http://checkip.amazonaws.com
# curl http://smart-ip.net/myip
 Результатом выполнения такой команды будет ваш внешний IP-адрес в сети Internet


Существуют и другие, более длинные варианты:

lynx --source http://formyip.com/ | awk '/The/{print $5}'
wget -q -O - http://formyip.com/ | awk '/The/{print $5}'
wget -q -O - http://checkip.dyndns.com/ | awk '{print $6}' | sed 's/<.*>//'

/*//
Эти решения для определения внешнего IP-адреса удобно использовать на хостах без графического веб-браузера и в скриптах командной оболочки, например:

#!/bin/bash

MYIP=$(wget -O - -q icanhazip.com);
echo $MYIP;

# ip route
default via 89.108.65.1 dev eth0
89.108.65.0/24 dev eth0 proto kernel scope link src 89.108.65.9
169.254.0.0/16 dev eth0 scope link metric 1002












2.   Базовая настройка Nginx
https://www.8host.com/blog/nastrojka-veb-servera-nginx/
NGINX – это мощный веб-сервер, использующий не потоковую, управляемую событиями архитектуру, которая позволяет ему превосходить Apache при правильной настройке (подробная информация здесь). Он также может выполнять другие важные функции, такие как балансировка нагрузки, кеширование HTTP и использование в качестве обратного прокси.

Проверка статуса запущеннго сервиса:
# systemctl status nginx


Root-каталог Nginx по умолчанию
Root-каталог веб-сервера находится в /usr/share/nginx/html. Файлы, размещенные в нем, будут обслуживаться веб-сервером. Это место определяется в конфигурационном файле блока server по умолчанию, который поставляется вместе с Nginx и находится в /etc/nginx/conf.d/default.conf.

Конфигурационный файл блока server
Блоки server – это технические характеристики отдельных веб-сайтов, размещённых на одном сервере.
Любые дополнительные блоки server (известные в Apache как виртуальные хосты, Virtual Hosts) вносятся путем создания нового конфигурационного файла в /etc/nginx/conf.d. Файлы этого каталога, которые заканчиваются на .conf, будут загружаться при запуске Nginx.

Глобальная настройка Nginx
Главный конфигурационный файл Nginx находится в /etc/nginx/nginx.conf. В нем можно изменить основные настройки (как, например, пользователя, который запускает процессы демона Nginx, а также количество рабочих процессов, которые создаются при запуске Nginx).


Работать мы будем с виртуальными сайтами и тут есть два варианта работы:

- Все правила для сайтов писать в конфигурационном файле /etc/nginx/nginx.conf,
- Создать для каждого виртуального сайта свой файл в /etc/nginx/conf.d с названием имя сайта.conf.
Мне удобней работать с файлами настроек для каждого сайта. Чтобы такая возможность была необходимо в главном файле присутствие строки include /etc/nginx/conf.d/*.conf.
/*//

Сервер может поддерживать больше одного сайта, а файлы, которые описывают сайты вашего сервера, находятся в каталоге /etc/nginx /sites-available.

Файлы в этом каталоге не являются «живыми» – у вас может быть столько файлов, описывающих сайты, сколько вы хотите, но веб-сервер ничего не будет с ними делать, если они не будут привязаны символической ссылкой на папку /etc/nginx/site-enabled.

Это дает вам возможность быстро помещать сайты в онлайн и отправлять их в автономный режим без фактического удаления каких-либо файлов. Когда вы будете готовы перевести сайт в онлайн – делайте символическую ссылку на sites-enabled и перезапускайте процесс.

В директории sites-available находится конфигурационный файл для виртуальных хостов. Этот файл позволяет настроить веб-сервер на мультисайтовость, чтобы каждый сайт имел свой отдельный конфиг. Сайты в этом каталоге не активны и будут включены только в том случае, если мы создадим символическую ссылку на папку sites-enabled.

/etc/nginx/nginx.conf — основной конфиг nginx, собственно с ним он и запускается.
/etc/nginx/sites-available/ — директория в которой лежат конфиги отдельных сайтов. Предполагается что конфиги сайтов должны лежать там и конфиг каждого сайта должен быть в отдельном файле. С файлов в этой директории (администратором) создаются симлинки в директорию /etc/nginx/sites-enabled/.
/etc/nginx/sites-enabled/ — директория все файлы из которой инклюдятся в nginx.conf (потому-что в nginx.conf есть директива include /etc/nginx/sites-enabled/*).
/*//
Соответственно /etc/nginx/sites-available/default это конфиг дефолтного сайта, а /etc/nginx/sites-enabled/default симлинк на него.

Смысл возни с симлинками в том что-бы иметь возможность быстро (и, при необходимости, автоматически) включать или отключать отдельные сайты, не возясь с комментированием больших кусков конфига.
Вместо создания симлинка можно перемещать конфиг из одной директории в другую.

<!-- У меня не создались папки sites-enabled и sites-available
Т.к. это  всего лишь один из способов организации конфигураций. Можно их не создавать и прописывать все в conf.d
а можно создать папки и дописать в основной конфиг директиву: include /etc/nginx/sites-enabled/*;
mkdir и тыды -->




Общее полезное:
Логи запросов и ошибок пишутся в /var/log/nginx/. Конфиги лежат в /etc/nginx/. В подкаталоге sites-available складываются все-все конфиги, даже те, которые вы раньше использовали, а теперь не используете. В sites-enabled складываются используемые конфиги, принято делать их линками на конфиги в sites-available.
После правки конфигов стоит проверить их на наличие синтаксических ошибок:
sudo nginx -t
Nginx умеет перечитывать конфиги без перезапуска. Для этого нужно сказать:
sudo service nginx reload
После reload обязательно проверяйте по логам, нет сыпятся ли какие ошибки:
sudo tail -f /var/log/nginx/error.log

_________________________________________________________

Практика
https://www.8host.com/blog/nastrojka-virtualnyx-xostov-nginx-v-centos-7/


1)  Структура каталогов
Для начала нужно создать структуру каталогов для хранения данных для сайтов.

Такие каталоги (каталоги верхнего уровня, в которых Nginx ищет запрашиваемый контент) называются document root. В каталоге /var/www нужно создать отдельные подкаталоги для каждого сайта. а в них – подкаталоги html для хранения файлов сайта.

Для создания каталогов используется команда mkdir, а флаг –p позволяет создать каталог с подкаталогом в нём.

# sudo mkdir -p /var/www/example.com/html
# sudo mkdir -p /var/www/example2.com/html

2) Права доступа
Теперь структура каталогов для сайтов готова, но все эти каталоги принадлежат пользователю root. Нужно передать права на них текущему пользователю, иначе он не сможет изменять данные. Для этого используйте команду chown:
# sudo chown -R $USER:$USER /var/www/example.com/html
# sudo chown -R $USER:$USER /var/www/example2.com/html

было (на подкаталог не смотрела)
[maria@89-108-65-9 ~]$ ls -ld /var/
drwxr-xr-x. 20 root root 4096 Mar 27 17:17 /var/
стало
[maria@89-108-65-9 ~]$ ls -ld /var/www/example.com/html
drwxr-xr-x 2 maria maria 4096 Mar 27 17:17 /var/www/example.com/html



Переменная $USER автоматически задаёт имя текущего пользователя. Теперь текущему пользователю принадлежат подкаталоги public_html, в которых будет храниться контент сайтов.

Также нужно немного изменить привилегии и открыть контент для чтения (иначе страницы не будут обслуживаться):

# sudo chmod -R 755 /var/www

Теперь сервер имеет необходимые права доступа и может корректно обслуживать контент в соответствующих каталогах.

*********

chmod - изменение атрибутов защиты файла
chown - смена собственника файла
755 - число определяется следущим образом: нужно предствить права доступа в двоичном виде(0 - отсутствие соответствуещего права, 1 - его наличие) и каждую триаду, соответсчвующую класу доступа, в свою очередь преобразовать в десятичное число.
7=111(rwx)  5=101(r-x)  4=100(r--)
-R  - Рекурсия. Изменить UserID и/или GroupID для всего дерева директорий и файлов начиная с указанной. Остерегайтесь совпадения с жесткой ссылкой на родительский каталог "..", при использовании шаблона ".*".
/*//
Если вы хотите изменить владельцев файлов из любого фрагмента дерева директорий, вы можете воспользоваться параметром -R. Например, если вам нужно изменить владельцев файлов дерева поддиректорий текущей директории на root, вы можете использовать следующую команду:

# chown -R root:root .

Вам наверняка захотелось использовать шаблон «*» для ссылки на все файлы. Однако, в этом случае не будет изменен владелец скрытых файлов (имена которых начинаются с символа точки). Также вы можете предположить, что следовало бы использовать шаблон «.*», однако, он будет соответствовать также директории с именем «..», в результате чего будет изменен владелец всех файлов также и в родительской директории! Следует помнить о том, что при использовании параметра -R утилите должно передаваться имя директории, а не имена отдельных файлов.

http://favoriteall.narod.ru/unix/chmod_chgrp_chown.html
*****************

3) Создание демо-страниц
Теперь нужно создать пару стандартных страниц сайтов, чтобы иметь возможность просмотреть контент.
Для тестирования подойдут и самые простые страницы. Создайте для каждого домена страницу index.html:
Чтобы создать страницу index.html для первого сайта, наберите:

# nano /var/www/example.com/html/index.html

*****
Nano - стандартный редактор в ubuntu, установка не нужна, стоит по умолчанию. Открыть и создать файл в nano просто. Нужно набрать:
# nano test.txt
Nano — немодальный редактор, и для вставки текста можно сразу начинать набор.
******

Добавьте в этот файл простой HTML-код:

<html>
<head>
<title>Welcome to Example.com!</title>
</head>
<body>
<h1>Привеееет!</h1>
</body>
</html>

Сохраните и закройте файл. ctrl+O  ctrl+X

Скопируйте этот файл и используйте его в качестве шаблона для страницы второго сайта:

# cp /var/www/example.com/html/index.html /var/www/example2.com/html/index.html

Откройте файл и подкорректируйте код:

# nano /var/www/example2.com/html/index.html
<html>
<head>
<title>Welcome to Example2.com!</title>
</head>
<body>
<h1>Привет 2</h1>
</body>
</html>

Сохраните и закройте файл.

4) Создание блоков Server
******
все-таки создать sites-available и sites-enabled для упрощения работы с хостами
sites-available складываются все-все конфиги, даже те, которые вы раньше использовали, а теперь не используете. В sites-enabled складываются используемые конфиги, принято делать их линками на конфиги в sites-available.
************

Итак, теперь файловая структура и страницы, обслуживающие контент, готовы к работе. Приступайте к созданию блоков server для Nginx.
Блоки server, или виртуальные хосты, помогают веб-серверу Nginx обслуживать несколько сайтов с разным контентом.
Для начала создайте каталог для хранения файлов хостов (sites-available), а также каталог, предоставляющий Nginx список хостов, которые нужно обслуживать (sites-enabled).
# sudo mkdir /etc/nginx/sites-available
# sudo mkdir /etc/nginx/sites-enabled

После этого нужно сообщить , что доступные блоки server хранятся в каталоге sites-enabled. Для этого нужно отредактировать главный конфигурационный файл Nginx, добавив в него строку, сообщающую о других конфигурационных файлах:
*НЕ ПОЛУЧИЛОСЬ!!*
!!!!!!!!
Только сначала сделать копии
# cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.orig
Не дает поставить разрешение orig
cp: cannot create regular file ‘/etc/nginx/nginx.conf.orig’: Permission denied
и так не дает
cp /etc/nginx/nginx.conf /etc/nginx/nginx.orig.conf
cp /etc/nginx/nginx.conf /etc/nginx/nginx_orig.conf
cp /etc/nginx/nginx.conf /etc/nginx/sites-available/nginx.orig.conf


проверить, пробовала ли под рутом
т.к пыталась скопировать конфиг из одного в другой
cp /etc/nginx/sites-available/example.com.conf /etc/nginx/sites-available/example2.com.conf
и тоже получила сообщение о расширении
а под рутом скопирвоалось
!!!!!!!!!!!!!!

# sudo nano /etc/nginx/nginx.conf

Добавьте эти строки в конец блока http {}:
  include /etc/nginx/sites-enabled/*.conf;
  server_names_hash_bucket_size 64;
/*//
  Первая строка указывает, что виртуальные хосты находятся в каталоге sites-enabled, а вторая строка увеличивает объем памяти, выделенный для обработки доменов.


5) Создание виртуального хоста

По умолчанию Nginx предоставляет один стандартный блок server по имени default.conf, который можно использовать в качестве шаблона для других блоков. Скопируйте его:
#sudo cp /etc/nginx/conf.d/default.conf /etc/nginx/sites-available/example.com.conf

Примечание: Согласно требованиям все файлы виртуальных хостов Nginx должны иметь расширение .conf

!!!! только у меня в директории conf.d ничего нет
в nginx лежит файл nginx.conf.default
скопировала его
[maria@89-108-65-9 ~]$ sudo cp /etc/nginx/nginx.conf.default /etc/nginx/sites-available/example.com.conf
_______________________
Конфигурация:
*****
Каждое выражение Nginx должно заканчиваться символом точки с запятой. В противном случае возникнет ошибка.
*****
server:

server_name - сообщает Nginx, какие запросы нужно направлять на этот виртуальный хост. В этой строке нужно указать домен (например, example.com) и псевдонимы сайта (например, www.example.com); тогда домен с префиксом www и без него будет отображать один и тот же контент.
    server_name example.com www.example.com;
*****
  а можно вот так  
      server_name www.somesite.com;
      return 301 $scheme://somesite.com$request_uri;
Используется $scheme, которая подходит для http и https      
******

location:

root -  каталог document root (каталоги верхнего уровня, в которых Nginx ищет запрашиваемый контент)
    root /var/www/example.com/html;
*****
https://ruhighload.com/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F+%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F+nginx
Нет ничего плохого в размещении root-директории внутри location. Но если location не соответствует, то у нее не будет доступа к корневому каталогу. Правильнее указать root внутри секции server
          server {
              server_name www.somesite.com;
              root /var/www/nginx-default/;
                  location / {
                      # [...]
                  }
                  location /foo {
                      # [...]
                  }
                  location /bar {
                      # [...]
                  }
          }

***********
if=ЗЛО! Не используйте if для проверки наличия файла. Взамен у Nginx есть директива try_files
Проверка последовательности на наличие файла, если не существует, то отправляет на index.html
    try_files $uri $uri/ /index.html;
Директиву try_files удобно использовать в случае, если необходимо проверить несколько папок перед отдачей файла. Проверим наличие файла в папках /var/www и /var/storage
        server {
        	...
        	root /var/www;
        	try_files $uri /var/storage$uri;
        	...
        }    

*************

try_files - указать, что в случае если искомый файл или каталог не найден, сервер должен вернуть ошибку 404.
    try_files $uri $uri/ =404;



index


***********
Не нужно плодить большое количество директив index. Пропишите ее один раз в блоке http
Index будет автоматически наследоваться в всех секциях

                  http {
                      index index.php index.htm index.html;
                      server {
                          server_name www.somesite.com;
                          location / {
                              # [...]
                          }
                      }
                      server {
                          server_name somesite.com;
                          location / {
                              # [...]
                          }
                          location /foo {
                              # [...]
                          }
                      }
                  }

******





_______________________

Откройте новый файл и подкорректируйте настройки:

# sudo nano /etc/nginx/sites-available/example.com.conf

server {
	listen       80;
        server_name  example.com www.example.com;

       	#charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   /var/www/example.com/html;
       	    index  index.html index.htm;
            try_files $uri $uri/ =404;
        }

 	#error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
	error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root  /usr/share/nginx/html;
        }
}



5) Включение блоков server
Теперь блоки server готовы к использованию и их нужно включить. Для этого создайте символьную ссылку для каждого блока в каталог sites-enabled:
# sudo ln -s /etc/nginx/sites-available/example.com.conf /etc/nginx/sites-enabled/example.com.conf
# sudo ln -s /etc/nginx/sites-available/example2.com.conf /etc/nginx/sites-enabled/example2.com.conf

После этого перезапустите Nginx, чтобы обновить настройки сервера:

# sudo systemctl restart nginx
___________

Символическая ссылка (также известная как soft link или symlink) это  файл специального типа, который представляет собой ссылку на другой файл или каталог.
Символическая ссылка :  символический путь, абстрактно  указывающий  на расположение другого файла
Жесткая ссылка: обращается к конкретному местоположению физических данных
Символические ссылки создаются с помощью команды ln. Например, следующая команда создает символьную ссылку с именем link1 на файл с именем file1:
$ ln -s file1 link1
Теперь если просмотрим содержимое каталога с симлинком  мы увидим куда именно ссылается та, или иная ссылка. :
$ ls -l
-rw-r - r-- 1 user user 30 авг 26 21:23 file1 ->  /var/www/public_http/test.com/index.php
lrwxr-xr-x 1 user user 5 авг 26 21:23 link1 -> file1
Удалить ссылку можно командами rm или unlink
сам файл не удаляется

__________________

6)  Настройка локальных хостов (опционально)
Если вместо настоящих доменных имён вы использовали фиктивные имена, вы можете испытать новые виртуальные хосты, не подключаясь при этом к доменному имени. Для этого нужно настроить на компьютере локальные хосты.

Это не позволит другим посетителям просматривать сайт, но даст вам возможность проверить работу и настройки каждого сайта. Этот метод работает путем перехвата запросов, которые, как правило, поступают в DNS для разрешения доменных имен. Вместо этого можно указать IP-адреса, которые будут использоваться локальным компьютером  при поступлении запросов к доменным именам.

Примечание: Прежде чем приступить к выполнению данного раздела, убедитесь, что вы находитесь на локальном компьютере, а не на сервере. Для выполнения данного раздела нужно иметь root-права, чтобы редактировать системные файлы.

В системах Mac или Linux войдите как root-пользователь и откройте файл hosts:

# sudo nano /etc/hosts

Пользователи Windows могут обратиться за инструкциями к сайту Microsoft.

На данном этапе понадобится внешний IP-адрес сервера и домен, который вы хотели бы использовать на сайте:
(узнать ip  curl ifconfig.me)

89.108.65.9   localhost
89.108.65.9   guest-desktop
server_ip_address example.com
server_ip_address example2.com

*не знаю пока что сработало из 2х вариантов*
#Virtual hosts
#89.108.65.9   example2.com
#server_ip_address example2.com
89.108.65.9   mariatesting.com

Это направит запросы к доменам example.com и example2.com на локальный компьютер и передаст их на server_ip_address.

_______________________
Как проверить:

telnet 89.108.65.9 80
Trying 89.108.65.9...
Connected to 89-108-65-9.cloudvps.regruhosting.ru.
Escape character is '^]'.
GET / HTTP/1.1
HOST: example2.com

HTTP/1.1 200 OK
Server: nginx/1.12.2
Date: Thu, 28 Mar 2019 15:42:02 GMT
Content-Type: text/html
Content-Length: 136
Last-Modified: Thu, 28 Mar 2019 09:04:09 GMT
Connection: keep-alive
ETag: "5c9c8e09-88"
Accept-Ranges: bytes

<html>
<head>
<title>Welcome to Example.com!</title>
</head>
<body>
<h1>Привееееет! Тест Example  2!</h1>
</body>
</html>

*не получилось пока*
telnet 89.108.65.9 7070

GET / HTTP/1.1
HOST: mariatesting.com

продолжение
https://www.8host.com/blog/nastrojka-virtualnyx-xostov-nginx-v-centos-7/






____________________________________________-
1) Сделайте резервную копию конфигурационных файлов:

# cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.orig
# cp /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.conf.orig

2) Создать  для каждого виртуального сайта свой файл-конфиг в /etc/nginx/conf.d с названием имя сайта.conf
# cd /etc/nginx/conf.d
# touch examle1.com.conf

скопировать в него содержание /etc/nginx/conf.d/default.conf  (можно без 1го пункта пока)
# cp /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/examle1.com.conf
